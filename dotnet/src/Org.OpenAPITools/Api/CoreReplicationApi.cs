// <auto-generated>
/*
 * v2 API
 *
 * OpenAPI spec for Solr's v2 API endpoints
 *
 * The version of the OpenAPI document: 9.8.1
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Org.OpenAPITools.Client;
using System.Diagnostics.CodeAnalysis;

namespace Org.OpenAPITools.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface ICoreReplicationApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        CoreReplicationApiEvents Events { get; }

        /// <summary>
        /// Get a stream of a specific file path of a core
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="coreName"></param>
        /// <param name="filePath"></param>
        /// <param name="dirType">Directory type for specific filePath (cf or tlogFile). Defaults to Lucene index (file) directory if empty</param>
        /// <param name="offset">Output stream read/write offset (optional)</param>
        /// <param name="len"> (optional)</param>
        /// <param name="compression">Compress file output (optional, default to false)</param>
        /// <param name="checksum">Write checksum with output stream (optional, default to false)</param>
        /// <param name="maxWriteMBPerSec">Limit data write per seconds. Defaults to no throttling (optional)</param>
        /// <param name="generation">The generation number of the index (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFetchFileApiResponse"/>&gt;</returns>
        Task<IFetchFileApiResponse> FetchFileAsync(string coreName, string filePath, string dirType, Option<string> offset = default, Option<string> len = default, Option<bool> compression = default, Option<bool> checksum = default, Option<double> maxWriteMBPerSec = default, Option<long> generation = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get a stream of a specific file path of a core
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="coreName"></param>
        /// <param name="filePath"></param>
        /// <param name="dirType">Directory type for specific filePath (cf or tlogFile). Defaults to Lucene index (file) directory if empty</param>
        /// <param name="offset">Output stream read/write offset (optional)</param>
        /// <param name="len"> (optional)</param>
        /// <param name="compression">Compress file output (optional, default to false)</param>
        /// <param name="checksum">Write checksum with output stream (optional, default to false)</param>
        /// <param name="maxWriteMBPerSec">Limit data write per seconds. Defaults to no throttling (optional)</param>
        /// <param name="generation">The generation number of the index (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFetchFileApiResponse"/>?&gt;</returns>
        Task<IFetchFileApiResponse?> FetchFileOrDefaultAsync(string coreName, string filePath, string dirType, Option<string> offset = default, Option<string> len = default, Option<bool> compression = default, Option<bool> checksum = default, Option<double> maxWriteMBPerSec = default, Option<long> generation = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IFetchFileApiResponse"/>
    /// </summary>
    public interface IFetchFileApiResponse : Org.OpenAPITools.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class CoreReplicationApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnFetchFile;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorFetchFile;

        internal void ExecuteOnFetchFile(CoreReplicationApi.FetchFileApiResponse apiResponse)
        {
            OnFetchFile?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFetchFile(Exception exception)
        {
            OnErrorFetchFile?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class CoreReplicationApi : ICoreReplicationApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<CoreReplicationApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public CoreReplicationApiEvents Events { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="CoreReplicationApi"/> class.
        /// </summary>
        /// <returns></returns>
        public CoreReplicationApi(ILogger<CoreReplicationApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, CoreReplicationApiEvents coreReplicationApiEvents)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<CoreReplicationApi>();
            HttpClient = httpClient;
            Events = coreReplicationApiEvents;
        }

        partial void FormatFetchFile(ref string coreName, ref string filePath, ref string dirType, ref Option<string> offset, ref Option<string> len, ref Option<bool> compression, ref Option<bool> checksum, ref Option<double> maxWriteMBPerSec, ref Option<long> generation);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="coreName"></param>
        /// <param name="filePath"></param>
        /// <param name="dirType"></param>
        /// <param name="offset"></param>
        /// <param name="len"></param>
        /// <returns></returns>
        private void ValidateFetchFile(string coreName, string filePath, string dirType, Option<string> offset, Option<string> len)
        {
            if (coreName == null)
                throw new ArgumentNullException(nameof(coreName));

            if (filePath == null)
                throw new ArgumentNullException(nameof(filePath));

            if (dirType == null)
                throw new ArgumentNullException(nameof(dirType));

            if (offset.IsSet && offset.Value == null)
                throw new ArgumentNullException(nameof(offset));

            if (len.IsSet && len.Value == null)
                throw new ArgumentNullException(nameof(len));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="coreName"></param>
        /// <param name="filePath"></param>
        /// <param name="dirType"></param>
        /// <param name="offset"></param>
        /// <param name="len"></param>
        /// <param name="compression"></param>
        /// <param name="checksum"></param>
        /// <param name="maxWriteMBPerSec"></param>
        /// <param name="generation"></param>
        private void AfterFetchFileDefaultImplementation(IFetchFileApiResponse apiResponseLocalVar, string coreName, string filePath, string dirType, Option<string> offset, Option<string> len, Option<bool> compression, Option<bool> checksum, Option<double> maxWriteMBPerSec, Option<long> generation)
        {
            bool suppressDefaultLog = false;
            AfterFetchFile(ref suppressDefaultLog, apiResponseLocalVar, coreName, filePath, dirType, offset, len, compression, checksum, maxWriteMBPerSec, generation);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="coreName"></param>
        /// <param name="filePath"></param>
        /// <param name="dirType"></param>
        /// <param name="offset"></param>
        /// <param name="len"></param>
        /// <param name="compression"></param>
        /// <param name="checksum"></param>
        /// <param name="maxWriteMBPerSec"></param>
        /// <param name="generation"></param>
        partial void AfterFetchFile(ref bool suppressDefaultLog, IFetchFileApiResponse apiResponseLocalVar, string coreName, string filePath, string dirType, Option<string> offset, Option<string> len, Option<bool> compression, Option<bool> checksum, Option<double> maxWriteMBPerSec, Option<long> generation);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="coreName"></param>
        /// <param name="filePath"></param>
        /// <param name="dirType"></param>
        /// <param name="offset"></param>
        /// <param name="len"></param>
        /// <param name="compression"></param>
        /// <param name="checksum"></param>
        /// <param name="maxWriteMBPerSec"></param>
        /// <param name="generation"></param>
        private void OnErrorFetchFileDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string coreName, string filePath, string dirType, Option<string> offset, Option<string> len, Option<bool> compression, Option<bool> checksum, Option<double> maxWriteMBPerSec, Option<long> generation)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorFetchFile(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, coreName, filePath, dirType, offset, len, compression, checksum, maxWriteMBPerSec, generation);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="coreName"></param>
        /// <param name="filePath"></param>
        /// <param name="dirType"></param>
        /// <param name="offset"></param>
        /// <param name="len"></param>
        /// <param name="compression"></param>
        /// <param name="checksum"></param>
        /// <param name="maxWriteMBPerSec"></param>
        /// <param name="generation"></param>
        partial void OnErrorFetchFile(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string coreName, string filePath, string dirType, Option<string> offset, Option<string> len, Option<bool> compression, Option<bool> checksum, Option<double> maxWriteMBPerSec, Option<long> generation);

        /// <summary>
        /// Get a stream of a specific file path of a core 
        /// </summary>
        /// <param name="coreName"></param>
        /// <param name="filePath"></param>
        /// <param name="dirType">Directory type for specific filePath (cf or tlogFile). Defaults to Lucene index (file) directory if empty</param>
        /// <param name="offset">Output stream read/write offset (optional)</param>
        /// <param name="len"> (optional)</param>
        /// <param name="compression">Compress file output (optional, default to false)</param>
        /// <param name="checksum">Write checksum with output stream (optional, default to false)</param>
        /// <param name="maxWriteMBPerSec">Limit data write per seconds. Defaults to no throttling (optional)</param>
        /// <param name="generation">The generation number of the index (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFetchFileApiResponse"/>&gt;</returns>
        public async Task<IFetchFileApiResponse?> FetchFileOrDefaultAsync(string coreName, string filePath, string dirType, Option<string> offset = default, Option<string> len = default, Option<bool> compression = default, Option<bool> checksum = default, Option<double> maxWriteMBPerSec = default, Option<long> generation = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FetchFileAsync(coreName, filePath, dirType, offset, len, compression, checksum, maxWriteMBPerSec, generation, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get a stream of a specific file path of a core 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="coreName"></param>
        /// <param name="filePath"></param>
        /// <param name="dirType">Directory type for specific filePath (cf or tlogFile). Defaults to Lucene index (file) directory if empty</param>
        /// <param name="offset">Output stream read/write offset (optional)</param>
        /// <param name="len"> (optional)</param>
        /// <param name="compression">Compress file output (optional, default to false)</param>
        /// <param name="checksum">Write checksum with output stream (optional, default to false)</param>
        /// <param name="maxWriteMBPerSec">Limit data write per seconds. Defaults to no throttling (optional)</param>
        /// <param name="generation">The generation number of the index (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFetchFileApiResponse"/>&gt;</returns>
        public async Task<IFetchFileApiResponse> FetchFileAsync(string coreName, string filePath, string dirType, Option<string> offset = default, Option<string> len = default, Option<bool> compression = default, Option<bool> checksum = default, Option<double> maxWriteMBPerSec = default, Option<long> generation = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateFetchFile(coreName, filePath, dirType, offset, len);

                FormatFetchFile(ref coreName, ref filePath, ref dirType, ref offset, ref len, ref compression, ref checksum, ref maxWriteMBPerSec, ref generation);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/cores/{coreName}/replication/files/{filePath}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BcoreName%7D", Uri.EscapeDataString(coreName.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BfilePath%7D", Uri.EscapeDataString(filePath.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["dirType"] = ClientUtils.ParameterToString(dirType);

                    if (offset.IsSet)
                        parseQueryStringLocalVar["offset"] = ClientUtils.ParameterToString(offset.Value);

                    if (len.IsSet)
                        parseQueryStringLocalVar["len"] = ClientUtils.ParameterToString(len.Value);

                    if (compression.IsSet)
                        parseQueryStringLocalVar["compression"] = ClientUtils.ParameterToString(compression.Value);

                    if (checksum.IsSet)
                        parseQueryStringLocalVar["checksum"] = ClientUtils.ParameterToString(checksum.Value);

                    if (maxWriteMBPerSec.IsSet)
                        parseQueryStringLocalVar["maxWriteMBPerSec"] = ClientUtils.ParameterToString(maxWriteMBPerSec.Value);

                    if (generation.IsSet)
                        parseQueryStringLocalVar["generation"] = ClientUtils.ParameterToString(generation.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<FetchFileApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FetchFileApiResponse>();

                        FetchFileApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/cores/{coreName}/replication/files/{filePath}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterFetchFileDefaultImplementation(apiResponseLocalVar, coreName, filePath, dirType, offset, len, compression, checksum, maxWriteMBPerSec, generation);

                        Events.ExecuteOnFetchFile(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFetchFileDefaultImplementation(e, "/cores/{coreName}/replication/files/{filePath}", uriBuilderLocalVar.Path, coreName, filePath, dirType, offset, len, compression, checksum, maxWriteMBPerSec, generation);
                Events.ExecuteOnErrorFetchFile(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FetchFileApiResponse"/>
        /// </summary>
        public partial class FetchFileApiResponse : Org.OpenAPITools.Client.ApiResponse, IFetchFileApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FetchFileApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FetchFileApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FetchFileApiResponse(ILogger<FetchFileApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => true;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
